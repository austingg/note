I am try to implement free-hand sketching(it should look like a pencil). I did some research and surprised there is so little info about this on the internet. The best information I got was by drawing photoshop and observing the result. I think Photoshop works something similar like this:
1) Each brush has its own pixel map, telling what opacity has each pixel.
2) Setting(like weight, color) apply to this pixel map before drawing.
3)But I think it also some kind of transformation to the patter, because line does not look regular.

*********************************************
Gradient fill algorithm

Most of the ones I've seen simply add a factor of the difference between the starting and ending color, with the factor being determined  by the number of gradeint steps.

Nothing fancy, but they look fine, depending on the number of step you perform.

Second was coded by me when I needed a gradient distribution of colour in x and y direction. I know that it is a BFT(Brute Force Technique) and is not efficient. One can speed up by using BitBlt, But it is far from satisfactory.

If you come across more efficient method, please let me know.


*************************************************
design pattern

The flattenable interface allows an object to serialize itself out to a byte-buffer and an array of file descriptors.

SKFlattenable is the based class for objects that need to be flattenable into a data stream for either transport or as part of the key to the font cache.



***************************************************
Android 2D graphics pipeline

If no Rasterizer has been set then the default rasterization process is used:

1. The Path is scan-converted based on parameter from the paint and the path to produce an initial mask. 
   Pixels "inside" the Path will become opaque, those "outside" will be left transparent, and those on the boundary my become partially transparent(for anti-aliasing). The mask will end up containing an opaque silhoette of the object. 
2. If there is a mask Filter set, then the initial mask


Shading is the process of determining the "source colour" for each pixeels.

The actual implementation doesn't use a bitmap, but rather uses a function that maps(x, y)to an ARGB colour for the given pixel.

**************************************************************
In computer graphics, a colour gradient(sometimes called color ramp or color progression) specifies a range of position-dependent colors, usually used to fill a region.

An axial color gradient(sometimes also called a linear color gradient) is specified by two points, and a color at each point. The colors along the lien through those points are calculated using linear interpolation, then extended perpendicular to that line. 

a radial gradient is specified as a circle that has one color at the edge and other at the center. colors are calculated by linear interpolation based on distance from the center.


**************************************************************
SDL does not ship with any built-in mechanism for drawing or filling circles. This tutorial wihil show you a method for accomplishing each task without using trigonometry.

for drawing circles we will use the midpoint circle algorithm, while for filling circles we will manipulate the formula for the radius of an arc;


********************************************************
be about to



SkMatrix   SkRegion  SkIRect SkRect
SkBillter   SkMask   SkClipStack   SkString
SkSort    SkTArray


********************************************************
Pen and Brush Options

pen and brush shapes can be stored in a pixel array that identifies the array of pixel positions that are to be set along the line path. To avoid setting pixels more than once in the frame buffer, we can simply accumulate the horizontal spans generated at each position of the mask and keep track of the beginning and ending x positions for the spans across each scan line.



********************************************************
Skia is organized around the Canvas object. It is the host for the "draw" calls: drawRect, drawPath, drawText, etc. Each of these has two components: the primitive being drawn(SkRect, SkPath, etc.) and color/style attributes(SkPaint);

canvas.drawRect(rect, paint);

The paint holds much of the state describing how the rectangle(in this case) is drawn: what color it is, if it is filled or stroked, how it should blend with what was previously drawn.

The canvas holds relative little state. It points to the actual pixels being drawn(hosted by a Bitmap), and it maintains a stack of matrices and clips. Thus in the above call, the canvas' current matrix may transform the coordinates of the rectangle(translation, rotation, skewing, perspective), and the canvas' current clip may restrict where on the canvas the rectangle will be drawn, but all other stylistic attributes of the drawing are controlled by the paint.


Anytime you draw something in Skia, and want to specify what color it is, or how it blends with the background, or what style or font to draw it in you specify those attributes in a paint.

Unlike SkCanvas, paints do not maintain an internal stack of state(i.e. there is no save / restore on a paint). However, paint are reletively light weight, so the client may create and maintain any number of paint objects, each setup for a particular use. 

SkPaint paint1, paint2, paint3;

paint1.setColor(0xFFFF0000);
paint1.setStyle(SkPaint::kStroke_Style);

paint2.setColor(0x8000FF00);
paint2.setStyle(SkPaint::kFill_Style);


SkShader* shader = SkGradientShader::CreateLinear(....);
paint.setShader(shader);
shader->unref();

anything drawn with that paint will be drawn with the gradient specified in the call to CreateLinear(). The Shader object that is returned is reference-counted. Whenever any effects object, like a shader, is assigned to paint, its reference-count increased by the paint. To balance this, the caller in the above example call unref() on the shader once it has assigned to the paint. Now the paint is the only owner of that shader, and it will automatically call unref() on the shader when either the paint goes out the scope, or if another shader(or null) is assigned to it.


SkGradientShader hosts factories for creating subclasses of SkShader that render linear and radial gradients.


SkBlitter and its subclasses are responsible for actually writing pixels into memory. Besides efficiency, they handle clipping and antialiasing.


blit a pattern of pixels defined by a rectangle-clipped mask
virtual void blitMask(const SkMask&, const SkIRect& clip);


SkXfermode is the base class for objects that are called to implement custom "transfer-modes" in the drawing pipeline. The static function Create(Modes) can be called to return an instance of any of the predefined subclass as specified in the modes enum. When an SkXfermode is assigned to an SkPaint, then objects drawn with that paint have the xfermode applied.

SkRecord(REC-ord)represents a sequence of SkCanvas calls, saved for future use. These future use may include: replay, optimization, serialization or combinations of those.

SkRecorder provides an SkCanvas interface for recording into an SkRecord.

Shading is the process of determining the "source colors" for each pixel. A color consist of alpha, red, green, and blue components. At a high level, the output of the shader can be thought of as a virtual image containing the source colors: the source image. The actual implementation doesn't use a bitmap, but rather uses a function that maps from(x, y) to an ARGB color for the given pixel, and this function is only called for coordinates where the corresponding pixel may be altered by the source color. This is really just an optimization, however.

The shader does not get the mask, the path, or the destination image as inputs.

***********************************************************
in addition to the coordinate list, can you get timestamps?
That might let you darken the runs when the user was drawing slowly or hesitating.

fair enough, it's pen-like. But as I said, should be easy to convert brush-like.


A pastel preset would use a continuous fiber-pressed paper like perpaer ingres simulated by this kind of pattern, a squary brush mask simulate the foot print of a pastel block. 

The pattern seams to react just as a alpha mask acting in addition to the brush mask.

In a computer system, a blitter is a circuit, sometimes as a coprocessor or a logic block on microprocessor, that is dedicated to the rapid movement and modification fo data within that computer's memory. a blitter is capable of copying large quantities of data from one memory are to another relatively quickly, and in parallel with the cpu.

The name comes from BLIT, which is not a acronym but is often interpreted as Block Image Transfer. A typical used for a blitter is the movement of a bitmap, such as windows and fonts in a graphical user interface or sprites and backgrounds in a 2D computer game.

1. Artistic thresholding
2. State of the Art: A taxonomy of Artistic stylization techniques for image and video
3. Topology-driven vetorization of clean line drawing
4. Adaptive vectorization of line drawing images.

******************************************************

Gradient primitive


The most common parameterization are linear, radial and polar.

if possible, there should be a graduation in user-invovement.

*******************************************************
Depth buffer

Enabling depth buffering

in order to use depth buffering, the following must occur:

The current framebuffer, whether an FBO or the default framebuffer, must have a depth buffer.

depth testing must be enabled. This is done by calling glEnable(GL_DEPTH_TEST). By default depth testing is disabled when you create the GL context;

the depth function should be set with glDepthFunc. We recommend glDepthFunc(GL_LEQUAL)where LEQUAL means less or equal.

the depth mask is set with glDepthMask. By default, this is GL_TRUE which means writing to the depth buffer is enable.

**********************************************************
The RBF interpolation relies on solution of a LSE Ax = b of the size M*M 
in principle, where M is a number of the data processed. However, in visualization applications it is many times and even for already computed value, the computation of f(x) is too expensive. Therefor it is reasonable to significantly reduce the dimensionality of the LSE Ax = b. Of course, we are now changing the the interpolation property of the RBF to approximation, i.e. the values computed do not pass the given values exactly.

*******************************
Tone mapping 

Tone mapping is a technique used in image processing and computer graphics to map one set of color to another.



**********************************************
Enlarging an image (upsampling or interpolating) zooming 


Polyharmonic splines are used for function approximation and data interpolation. They are useful for interpolation of scatter data in many dimensions. A special case is thin plane splines.


Main disadvantages are:
1. To determine the weights, a linear system of equations must be solved, which is non-sparse. The solution of a non-space linear system becomes no longer practical if the dimension n is larger as about 1000(since the storage requirements are O(n^2) and the number of operations to solve the linear system is O(n^3). For example n = 10000 requires about 100Mbyte of storage and 1000G flops of operations.

2. To perform the interpolation of M data points requires operations in the order of O(M*N). In many applications, like image processing. M is much larger than N, and if both numbers are large, this is no longer practical.

Recently, method have been developed to overcome the aforementioned difficulties. For example Beatson present a method to interpolate polyharmonic splines at one point in 3 dimension in O(log(n)) instead of O(n).


Lanczos resampling or Lanczos filter is a mathmatical formula used to smoothly  interpolate the value of a digital signal between its samples. It maps each sample of the given signal to translated and scaled copy of the Lanczos kernel, which is a sinc funcion windowed by the central hump of a dilated sinc function.

Inverse distance weighting

Inverse Distance Weight is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to unknown points are calculated with a weighted average of the value available at he known points.

the name given to this type of methods was motivated by the weighted average applied since it resorts to the inverse of the distance to each known point(amount of the proximity) when assign weights.






*************************************************************************
Linear Algebra
Trigonometry

approximation theory


The LU-decomposition used in this example is generic, direct solver that doesn't scale well as the size of the matrices grow large: it is O(N^3). For large sets of control points, there are optimized(and much more complicated)methods for solving the thin palte spline problem(or more generally, RBF or Radial Basis Function interpolation). They are based on iterative numerical solvers(like Gauss-Sediel or the conjugate gradient method) and the assumption that the effect of the control points is mainly local(i.e. only a few neighboring control points contribute majority to interpolating a given point). These approximations scale well, in the order of O(NlogN)(albeith with pretty high constraints).

For a good, readable introduction to these methods(preconditining, Krylov subsapce method, fast multipole algorithm)see: "Radias basis functions: theory and implementations" by Martin Dietrich Buhmann.

The RBF interpolation is not separable and it is based on distance of two points. It leads to a solution of Linear system of Equations(LSE) Ax=b. There are two main groups of interpolating functions: global and local. Application of local function, called compactly supporting RBF(CSFBF), can significantly decrease computational cost as they lead to a system of linear equations with s sparse matrix.


SVD method has very high numerical robustness, but this robustness has its price both in space and in time. If you don't expect a degenrated case , you can have much lighter methods that should be able to run on x86.


In applied mathematics and theoretical computer science, combinatorial
optimization is a topic that consists of finding an optimal object from a
finite set of objects. In many such problems, exhaustive search is not
feasible.


Specific problems
Assignment problem
